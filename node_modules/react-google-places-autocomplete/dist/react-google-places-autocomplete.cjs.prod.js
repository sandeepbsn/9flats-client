"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _regeneratorRuntime = _interopDefault(require("@babel/runtime/regenerator")), _asyncToGenerator = _interopDefault(require("@babel/runtime/helpers/asyncToGenerator")), _extends = _interopDefault(require("@babel/runtime/helpers/extends")), _assertThisInitialized = _interopDefault(require("@babel/runtime/helpers/assertThisInitialized")), _inheritsLoose = _interopDefault(require("@babel/runtime/helpers/inheritsLoose")), _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), React = _interopDefault(require("react")), PropTypes = _interopDefault(require("prop-types")), _construct = _interopDefault(require("@babel/runtime/helpers/construct")), INJECTION_STATE_NOT_YET = "not yet", INJECTION_STATE_IN_PROGRESS = "in progress", INJECTION_STATE_DONE = "done", injectionState = INJECTION_STATE_NOT_YET, injectionError = null, onScriptLoadCallbacks = [], onScriptLoadErrorCallbacks = [], injectScript = function(apiKey) {
  switch (injectionState) {
   case INJECTION_STATE_DONE:
    return injectionError ? Promise.reject(injectionError) : Promise.resolve();

   case INJECTION_STATE_IN_PROGRESS:
    return new Promise((function(resolve, reject) {
      onScriptLoadCallbacks.push(resolve), onScriptLoadErrorCallbacks.push(reject);
    }));

   default:
    return injectionState = INJECTION_STATE_IN_PROGRESS, new Promise((function(resolve, reject) {
      var script = document.createElement("script");
      script.type = "text/javascript", script.src = "https://maps.googleapis.com/maps/api/js?key=" + apiKey + "&libraries=places", 
      script.async = !0, script.defer = !0;
      var onScriptLoad = function() {
        resolve(), onScriptLoadCallbacks.forEach((function(cb) {
          return cb();
        })), cleanup();
      }, onScriptLoadError = function() {
        injectionError = new Error("[react-google-places-autocomplete] Could not inject Google script"), 
        reject(injectionError), onScriptLoadErrorCallbacks.forEach((function(cb) {
          return cb(injectionError);
        })), cleanup();
      }, cleanup = function() {
        script.removeEventListener("load", onScriptLoad), script.removeEventListener("error", onScriptLoadError), 
        onScriptLoadCallbacks = [], onScriptLoadErrorCallbacks = [], injectionState = INJECTION_STATE_DONE;
      };
      script.addEventListener("load", onScriptLoad), script.addEventListener("error", onScriptLoadError), 
      document.body.appendChild(script);
    }));
  }
}, autocompletionRequestBuilder = function(autocompletionRequest) {
  var res = _extends({}, autocompletionRequest);
  return autocompletionRequest.bounds && (res.bounds = _construct(google.maps.LatLngBounds, autocompletionRequest.bounds)), 
  autocompletionRequest.location && (res.location = new google.maps.LatLng(autocompletionRequest.location)), 
  res;
}, debounce = function(callback, timeout) {
  var d, e;
  return function() {
    function helper() {
      d = null, e = callback.apply(thisRef, argumentsRef);
    }
    var thisRef = this, argumentsRef = arguments;
    return clearTimeout(d), !(d = setTimeout(helper, timeout)) && (e = callback.apply(thisRef, argumentsRef)), 
    e;
  };
}, latLngBoundsType = function(props, propName, componentName) {
  var prop = props[propName];
  return prop ? Array.isArray(prop) && 2 === prop.length && prop.every((function(value) {
    return 2 === Object.keys(value).length && value.hasOwnProperty("lat") && value.hasOwnProperty("lng") && Number(value.lat) && Number(value.lng);
  })) ? null : new Error("Invalid prop `" + propName + "` supplied to `" + componentName + "`. Validation failed.") : null;
}, componentRestrictionsType = PropTypes.shape({
  country: PropTypes.oneOfType([ PropTypes.string, PropTypes.arrayOf(PropTypes.string) ])
}), latLngType = PropTypes.shape({
  lat: PropTypes.number,
  lng: PropTypes.number
}), autocompletionRequestType = PropTypes.shape({
  bounds: latLngBoundsType,
  componentRestrictions: componentRestrictionsType,
  location: latLngType,
  offset: PropTypes.number,
  radius: PropTypes.number,
  types: PropTypes.arrayOf(PropTypes.string)
}), suggestionClassNamesType = PropTypes.shape({
  container: PropTypes.string,
  suggestion: PropTypes.string,
  suggestionActive: PropTypes.string
}), suggestionStylesType = PropTypes.shape({
  container: PropTypes.object,
  suggestion: PropTypes.object
}), GooglePlacesAutocomplete = function(_React$Component) {
  function GooglePlacesAutocomplete(props) {
    var _this;
    return _this = _React$Component.call(this, props) || this, _defineProperty(_assertThisInitialized(_this), "fetchSuggestions", debounce((function(value) {
      if (_this.placesService) {
        var _this$props = _this.props, autocompletionRequest = _this$props.autocompletionRequest, withSessionToken = _this$props.withSessionToken, sessionToken = _this.state.sessionToken, autocompletionReq = _extends({}, autocompletionRequest);
        withSessionToken && sessionToken && (autocompletionReq.sessionToken = sessionToken), 
        _this.setState({
          loading: !0
        }), _this.placesService.getPlacePredictions(_extends({}, autocompletionRequestBuilder(autocompletionReq), {
          input: value
        }), _this.fetchSuggestionsCallback);
      }
    }), _this.props.debounce)), _defineProperty(_assertThisInitialized(_this), "initializeService", (function() {
      if (!window.google) throw new Error("[react-google-places-autocomplete]: Google script not loaded");
      if (!window.google.maps) throw new Error("[react-google-places-autocomplete]: Google maps script not loaded");
      if (!window.google.maps.places) throw new Error("[react-google-places-autocomplete]: Google maps places script not loaded");
      _this.placesService = new window.google.maps.places.AutocompleteService, _this.setState({
        placesServiceStatus: window.google.maps.places.PlacesServiceStatus.OK
      }), _this.generateSessionToken();
    })), _defineProperty(_assertThisInitialized(_this), "generateSessionToken", (function() {
      var sessionToken = new google.maps.places.AutocompleteSessionToken;
      _this.setState({
        sessionToken: sessionToken
      });
    })), _defineProperty(_assertThisInitialized(_this), "handleClick", (function(ev) {
      var idPrefix = _this.props.idPrefix;
      ev.target.id.includes(idPrefix + "-google-places-autocomplete") || _this.clearSuggestions();
    })), _defineProperty(_assertThisInitialized(_this), "changeValue", (function(value) {
      var minLengthAutocomplete = _this.props.minLengthAutocomplete;
      _this.setState({
        value: value
      }), value.length > minLengthAutocomplete ? _this.fetchSuggestions(value) : _this.setState({
        suggestions: []
      });
    })), _defineProperty(_assertThisInitialized(_this), "onSuggestionSelect", (function(suggestion, ev) {
      void 0 === ev && (ev = null), ev && ev.stopPropagation();
      var _this$props2 = _this.props, displayFromSuggestionSelected = _this$props2.displayFromSuggestionSelected, onSelect = _this$props2.onSelect;
      _this.setState({
        activeSuggestion: null,
        suggestions: [],
        value: displayFromSuggestionSelected(suggestion)
      }), _this.generateSessionToken(), onSelect(suggestion);
    })), _defineProperty(_assertThisInitialized(_this), "fetchSuggestionsCallback", (function(suggestions, status) {
      _this.state.placesServiceStatus;
      _this.setState({
        loading: !1,
        suggestions: suggestions || []
      });
    })), _defineProperty(_assertThisInitialized(_this), "handleKeyDown", (function(event) {
      var _this$state = _this.state, activeSuggestion = _this$state.activeSuggestion, suggestions = _this$state.suggestions;
      switch (event.key) {
       case "Enter":
        event.preventDefault(), null !== activeSuggestion && _this.onSuggestionSelect(suggestions[activeSuggestion]);
        break;

       case "ArrowDown":
        _this.changeActiveSuggestion(1);
        break;

       case "ArrowUp":
        _this.changeActiveSuggestion(-1);
        break;

       case "Escape":
        _this.clearSuggestions();
      }
    })), _defineProperty(_assertThisInitialized(_this), "clearValue", (function() {
      _this.setState({
        value: ""
      }), _this.clearSuggestions();
    })), _defineProperty(_assertThisInitialized(_this), "clearSuggestions", (function() {
      _this.setState({
        activeSuggestion: null,
        suggestions: []
      });
    })), _defineProperty(_assertThisInitialized(_this), "onHoverOverSuggestion", (function(index) {
      0 !== _this.state.suggestions.length && _this.setState({
        activeSuggestion: index
      });
    })), _defineProperty(_assertThisInitialized(_this), "renderInput", (function() {
      var _assertThisInitialize = _assertThisInitialized(_this), value = _assertThisInitialize.state.value, _assertThisInitialize2 = _assertThisInitialize.props, idPrefix = _assertThisInitialize2.idPrefix, inputClassName = _assertThisInitialize2.inputClassName, inputStyle = _assertThisInitialize2.inputStyle, placeholder = _assertThisInitialize2.placeholder, renderInput = _assertThisInitialize2.renderInput, required = _assertThisInitialize2.required, disabled = _assertThisInitialize2.disabled;
      return renderInput ? renderInput({
        autoComplete: "off",
        id: (idPrefix ? idPrefix + "-" : "") + "react-google-places-autocomplete-input",
        value: value,
        onChange: function(_ref) {
          var target = _ref.target;
          return _this.changeValue(target.value);
        },
        onKeyDown: _this.handleKeyDown,
        type: "text",
        placeholder: placeholder,
        required: required,
        disabled: disabled
      }) : React.createElement("input", {
        autoComplete: "off",
        className: inputClassName || "google-places-autocomplete__input",
        id: (idPrefix ? idPrefix + "-" : "") + "react-google-places-autocomplete-input",
        onChange: function(_ref2) {
          var target = _ref2.target;
          return _this.changeValue(target.value);
        },
        onKeyDown: _this.handleKeyDown,
        placeholder: placeholder,
        style: inputStyle,
        type: "text",
        value: value,
        required: required,
        disabled: disabled
      });
    })), _defineProperty(_assertThisInitialized(_this), "renderLoader", (function() {
      var loader = _this.props.loader;
      return loader || React.createElement("div", {
        className: "google-places-autocomplete__suggestions-container"
      }, React.createElement("div", {
        className: "google-places-autocomplete__suggestions"
      }, "Loading..."));
    })), _defineProperty(_assertThisInitialized(_this), "renderSuggestions", (function() {
      var _assertThisInitialize3 = _assertThisInitialized(_this), _assertThisInitialize4 = _assertThisInitialize3.state, activeSuggestion = _assertThisInitialize4.activeSuggestion, suggestions = _assertThisInitialize4.suggestions, _assertThisInitialize5 = _assertThisInitialize3.props, idPrefix = _assertThisInitialize5.idPrefix, renderSuggestions = _assertThisInitialize5.renderSuggestions, suggestionsClassNames = _assertThisInitialize5.suggestionsClassNames, suggestionsStyles = _assertThisInitialize5.suggestionsStyles;
      return renderSuggestions ? renderSuggestions(activeSuggestion, suggestions, _this.onSuggestionSelect) : 0 === suggestions.length ? null : React.createElement("div", {
        id: idPrefix + "-google-places-suggestions-container",
        className: suggestionsClassNames.container || "google-places-autocomplete__suggestions-container",
        style: suggestionsStyles.container
      }, suggestions.map((function(suggestion, index) {
        return React.createElement("div", {
          id: idPrefix + "-google-places-autocomplete-suggestion--" + index,
          key: suggestion.place_id,
          className: (suggestionsClassNames.suggestion || "google-places-autocomplete__suggestion") + " " + (activeSuggestion === index ? suggestionsClassNames.suggestionActive || "google-places-autocomplete__suggestion--active" : ""),
          style: suggestionsStyles.suggestion,
          onClick: function(event) {
            return _this.onSuggestionSelect(suggestion, event);
          },
          onMouseEnter: function() {
            return _this.onHoverOverSuggestion(index);
          },
          role: "presentation"
        }, suggestion.description);
      })));
    })), _this.state = {
      activeSuggestion: null,
      loading: !1,
      placesServiceStatus: null,
      sessionToken: null,
      suggestions: [],
      value: props.initialValue
    }, _this;
  }
  _inheritsLoose(GooglePlacesAutocomplete, _React$Component);
  var _proto = GooglePlacesAutocomplete.prototype;
  return _proto.componentDidMount = function() {
    var _componentDidMount = _asyncToGenerator(_regeneratorRuntime.mark((function _callee() {
      var _this$props3, apiKey, onLoadFailed;
      return _regeneratorRuntime.wrap((function(_context) {
        for (;;) switch (_context.prev = _context.next) {
         case 0:
          if (_this$props3 = this.props, apiKey = _this$props3.apiKey, onLoadFailed = _this$props3.onLoadFailed, 
          _context.prev = 1, !apiKey) {
            _context.next = 5;
            break;
          }
          return _context.next = 5, injectScript(apiKey);

         case 5:
          this.initializeService(), document.addEventListener("click", this.handleClick), 
          _context.next = 12;
          break;

         case 9:
          _context.prev = 9, _context.t0 = _context.catch(1), onLoadFailed(_context.t0);

         case 12:
         case "end":
          return _context.stop();
        }
      }), _callee, this, [ [ 1, 9 ] ]);
    })));
    return function() {
      return _componentDidMount.apply(this, arguments);
    };
  }(), _proto.componentWillUnmount = function() {
    document.removeEventListener("click", this.handleClick);
  }, _proto.UNSAFE_componentWillReceiveProps = function(nextProps) {
    var initialValue = this.props.initialValue;
    nextProps.initialValue !== initialValue && this.setState({
      value: nextProps.initialValue
    });
  }, _proto.changeActiveSuggestion = function(direction) {
    if (0 !== this.state.suggestions.length) switch (direction) {
     case 1:
      this.setState((function(_ref3) {
        var activeSuggestion = _ref3.activeSuggestion, suggestions = _ref3.suggestions;
        return null === activeSuggestion || activeSuggestion === suggestions.length - 1 ? {
          activeSuggestion: 0
        } : {
          activeSuggestion: activeSuggestion + 1
        };
      }));
      break;

     case -1:
      this.setState((function(_ref4) {
        var activeSuggestion = _ref4.activeSuggestion, suggestions = _ref4.suggestions;
        return activeSuggestion ? {
          activeSuggestion: activeSuggestion - 1
        } : {
          activeSuggestion: suggestions.length - 1
        };
      }));
    }
  }, _proto.render = function() {
    var loading = this.state.loading;
    return React.createElement("div", {
      className: "google-places-autocomplete"
    }, this.renderInput(), loading ? this.renderLoader() : this.renderSuggestions());
  }, GooglePlacesAutocomplete;
}(React.Component);

GooglePlacesAutocomplete.propTypes = {}, GooglePlacesAutocomplete.defaultProps = {
  apiKey: "",
  autocompletionRequest: {},
  debounce: 300,
  disabled: !1,
  displayFromSuggestionSelected: function(suggestion) {
    return suggestion.description;
  },
  idPrefix: "",
  initialValue: "",
  inputClassName: "",
  inputStyle: {},
  loader: null,
  minLengthAutocomplete: 0,
  onLoadFailed: console.error,
  onSelect: function() {},
  placeholder: "Address...",
  renderInput: void 0,
  renderSuggestions: void 0,
  required: !1,
  suggestionsClassNames: {
    container: "",
    suggestion: "",
    suggestionActive: ""
  },
  suggestionsStyles: {
    container: {},
    suggestion: {}
  },
  withSessionToken: !1
};

var geocodeByAddress = function(address) {
  var geocoder = new window.google.maps.Geocoder, OK = window.google.maps.GeocoderStatus.OK;
  return new Promise((function(resolve, reject) {
    geocoder.geocode({
      address: address
    }, (function(results, status) {
      return status !== OK ? reject(status) : resolve(results);
    }));
  }));
}, getLatLng = function(result) {
  return new Promise((function(resolve, reject) {
    try {
      return resolve({
        lat: result.geometry.location.lat(),
        lng: result.geometry.location.lng()
      });
    } catch (e) {
      return reject(e);
    }
  }));
}, geocodeByPlaceId = function(placeId) {
  var geocoder = new window.google.maps.Geocoder, OK = window.google.maps.GeocoderStatus.OK;
  return new Promise((function(resolve, reject) {
    geocoder.geocode({
      placeId: placeId
    }, (function(results, status) {
      return status !== OK ? reject(status) : resolve(results);
    }));
  }));
};

exports.default = GooglePlacesAutocomplete, exports.geocodeByAddress = geocodeByAddress, 
exports.geocodeByPlaceId = geocodeByPlaceId, exports.getLatLng = getLatLng;
